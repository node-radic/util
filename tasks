#!/usr/bin/node --harmony
let path    = require('path'),
    fs      = require('fs'),
    globule = require('globule'),
    exec    = require('child_process').execSync,
    rollup  = require('rollup'),
    Promise = require('bluebird');

let args = process.argv.splice(2);
const command = args.shift();
const config = {
    fileName: 'radic.util',
    clean   : ['lib/*.{d.ts,js,js.map}', '*.{d.ts,js.map}', '!types.d.ts']
}

var log = function () {
    console.log.apply(console, arguments);
}
log.list = [];
log.add = (name) => {
    log.list.push(name)
}
log.has = (name) => {
    return log.list.indexOf(name) !== - 1;
}



var tasks = {
    compile(){
        log(exec('node_modules/.bin/tsc').toString());
        log.add('compile');
    },
    build() {
        this.compile();
        this.bundle();
        this.clean();
        log.add('build')
    },

    bundle: function () {
        log(exec('node_modules/.bin/rollup -c rollup.config.js').toString());
        log.add('bundle')
    },

    test: function () {
        ! log.has('compile') && this.compile();

        var Jasmine = require('jasmine');
        var jrunner = new Jasmine();
        var SpecReporter = require('jasmine-spec-reporter');
        var noop = function () {
        };
        var defer = Promise.defer();
        jrunner.configureDefaultReporter({print: noop});
        jasmine.getEnv().addReporter(new SpecReporter());
        jrunner.loadConfigFile('spec/support/jasmine.json');
        jrunner.onComplete(function (passed) {

            if ( passed ) {
                defer.resolve();
                console.log('All specs have passed');
            }
            else {
                defer.reject('At least one spec has failed');
                console.log('At least one spec has failed');
            }
        });
        jrunner.execute();
        log.add('test');
        return defer.promise;
    },

    clean: function () {
        globule.find(config.clean).forEach((filePath) => {
            fs.unlinkSync(filePath)
            log('deleted', filePath);
        })
        log.add('clean');
    }
}


if ( ! tasks[command] ) {
    throw new Error('Not a workinng command')
}
tasks[command].apply(tasks, args);


process.exit()
